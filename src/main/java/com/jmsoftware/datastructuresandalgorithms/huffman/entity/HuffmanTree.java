package com.jmsoftware.datastructuresandalgorithms.huffman.entity;

import com.jmsoftware.datastructuresandalgorithms.common.util.KeyInputUtil;
import lombok.val;

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

/**
 * <h1>HuffmanTree</h1>
 * <p>
 * Change description here.
 *
 * @author Johnny Miller (鍾俊), email: johnnysviva@outlook.com
 * @date 5/24/20 10:52 PM
 **/
public class HuffmanTree {
    /**
     * Recursive function to print the huffman-code through the tree traversal.
     * Here s is the huffman - code generated.
     *
     * @param rootNode the root
     * @param string   the string
     */
    public static void recursivePrintHuffmanCode(HuffmanNode rootNode, String string) {
        if (rootNode == null) {
            return;
        }

        // base case; if the left and right are null
        // then its a leaf node and we print
        // the code s generated by traversing the tree.
        if (rootNode.isLeaf()) {
            // c is the character in the node
            System.out.println(rootNode.getCharacter() + ":" + string);
            return;
        }

        // if we go to left then add "0" to the code.
        // if we go to the right add "1" to the code.

        // recursive calls for left and
        // right sub-tree of the generated tree.
        recursivePrintHuffmanCode((HuffmanNode) rootNode.getLeftChildNode(), string + "0");
        recursivePrintHuffmanCode((HuffmanNode) rootNode.getRightChildNode(), string + "1");
    }

    /**
     * Recursive traverse in pre order huffman tree.
     *
     * @param rootNode       the root node
     * @param string         the string
     * @param huffmanCodeMap the huffman code map
     */
    public static void recursiveTraverseInPreOrderHuffmanTree(HuffmanNode rootNode, String string,
                                                              HashMap<Character, String> huffmanCodeMap) {
        if (rootNode == null) {
            return;
        }
        if (rootNode.isLeaf()) {
            huffmanCodeMap.put(rootNode.getCharacter(), string);
            return;
        }
        recursiveTraverseInPreOrderHuffmanTree((HuffmanNode) rootNode.getLeftChildNode(), string + "0", huffmanCodeMap);
        recursiveTraverseInPreOrderHuffmanTree((HuffmanNode) rootNode.getRightChildNode(), string + "1",
                                               huffmanCodeMap);
    }

    /**
     * Generate huffman tree huffman node.
     *
     * @param frequencyMap the frequency map
     * @return the huffman node
     */
    public static HuffmanNode generateHuffmanTree(Map<Character, Integer> frequencyMap) {
        // Create a priority queue q. Make a min-priority queue(min-heap).
        val size = frequencyMap.size();
        val huffmanNodePriorityQueue = new PriorityQueue<>(size, new HuffmanNode(null, null));

        frequencyMap.forEach((character, integer) -> {
            // Create a HuffmanTree node object and add it to the priority queue.
            val huffmanNode = new HuffmanNode(integer, character);
            huffmanNode.setLeftChildNode(null);
            huffmanNode.setRightChildNode(null);
            // Add functions adds the huffman node to the queue.
            huffmanNodePriorityQueue.add(huffmanNode);
        });

        // Here we will extract the two minimum value from the heap each time until its size reduces to 1. Extract
        // until all the nodes are extracted.
        while (huffmanNodePriorityQueue.size() > 1) {
            // first min extract.
            val leftNode = huffmanNodePriorityQueue.peek();
            huffmanNodePriorityQueue.poll();
            // second min extract.
            val rightNode = huffmanNodePriorityQueue.peek();
            huffmanNodePriorityQueue.poll();
            // new node f which is equal
            assert rightNode != null;
            val mergedNode = new HuffmanNode(leftNode.getWeight() + rightNode.getWeight() ,null);
            // Sum of the frequency of the two nodes. Assign values to the mergedNode
            // first extracted node as left child.
            mergedNode.setLeftChildNode(leftNode);
            // second extracted node as the right child.
            mergedNode.setRightChildNode(rightNode);
            // add this node to the priority-queue.
            huffmanNodePriorityQueue.add(mergedNode);
        }
        return huffmanNodePriorityQueue.poll();
    }

    /**
     * Calculate frequency map.
     *
     * @param inputString the input string
     * @return the map
     */
    public static Map<Character, Integer> calculateFrequency(String inputString) {
        val frequencyMap = new HashMap<Character, Integer>(32);
        for (var index = 0; index < inputString.length(); index++) {
            var character = inputString.charAt(index);
            var frequency = frequencyMap.get(character);
            if (frequency == null) {
                frequencyMap.put(character, 1);
            } else {
                frequencyMap.put(character, ++frequency);
            }
        }
        return frequencyMap;
    }

    public static void main(String[] args) {
        System.out.print("Input string: ");
        val inputString = KeyInputUtil.readString();
        val frequencyMap = calculateFrequency(inputString);
        System.out.println("Frequency map: " + frequencyMap);
        val rootNode = generateHuffmanTree(frequencyMap);
        recursivePrintHuffmanCode(rootNode, "");
        val huffmanCodeMap = new HashMap<Character, String>(32);
        recursiveTraverseInPreOrderHuffmanTree(rootNode, "", huffmanCodeMap);
        System.out.println("Huffman code map: " + huffmanCodeMap);
        System.out.println("Root: " + rootNode);
        val treeDiagramByTraversingInPreOrder = rootNode.getTreeDiagramByTraversingInPreorder();
        System.out.println(treeDiagramByTraversingInPreOrder);
    }
}
